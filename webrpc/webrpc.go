// Copyright 2013 Google. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

// Package webrpc implements a web-based JSON, Gob and ProtoBuf RPC protocol
// roughly compatible with google-protorpc.  It works in tandem with the
// go-rpcgen protoc-gen-go plugin, which generates the bindings.
//
// By default, webrpc.DefaultServeMux is handled by the default HTTP package,
// so it will interoperate with standard HTTP servers and AppEngine.
package webrpc

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
)

const (
	// DefaultRPCPath is the prefix of all RPC handlers registered by webrpc
	DefaultRPCPath = "/_webRPC_"
)

// A Protocol is a predefined encoder/decoder for WebRPC.
type Protocol interface {
	String() string // Return the MIME type of the protocol
	Decode(io.Reader, interface{}) error
	Encode(io.Writer, interface{}) error
}

// protocols stores the map of content types to known protocols
var protocols = map[string]Protocol{}

func RegisterProtocol(p Protocol) {
	protocols[p.String()] = p
}

// A Handler processes an incoming RPC request.  These are generated
// automatically by protoc-gen-go for service definitions and don't usually
// need to be registered manually.
type Handler func(*Call) error

// A Call is an incoming request.  These are used in the code generated
// automatically by protoc-gen-go.
type Call struct {
	http.ResponseWriter
	*http.Request

	ContentType string
}

// ReadRequest is used by the code generated automatically by protoc-gen-go.
func (c *Call) ReadRequest(pb interface{}) error {
	if proto, ok := protocols[c.ContentType]; ok {
		return proto.Decode(c.Request.Body, pb)
	}
	return fmt.Errorf("webrpc: read: %s: bad content type", c.ContentType)
}

// WriteResponse is used by the code generated automatically by protoc-gen-go.
func (c *Call) WriteResponse(pb interface{}) error {
	if proto, ok := protocols[c.ContentType]; ok {
		return proto.Encode(c.ResponseWriter, pb)
	}
	return fmt.Errorf("webrpc: write: %s: bad content type", c.ContentType)
}

// A ServeMux collects all of the handlers registered (usually by the
// Register...Web functions generated by protoc-gen-go) for handling
// by net/http.
type ServeMux map[string]Handler

// Handle adds a new handler for an RPC.  This is used by the code generated
// automatically by protoc-gen-go.
func (m ServeMux) Handle(path string, handler Handler) error {
	path = DefaultRPCPath + path
	if _, exist := m[path]; exist {
		return fmt.Errorf("webrpc: handler already registered for %q", path)
	}
	m[path] = handler
	return nil
}

// ServeHTTP creates a Call and calls the appropriate RPC handler for
// the given path.
func (m ServeMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()

	handler, found := m[r.URL.Path]
	if !found {
		w.Header().Set("Content-Type", "text/plain")
		http.Error(w, r.URL.Path+" is not a registered RPC", http.StatusNotFound)
		return
	}

	ctype := r.Header.Get("Content-Type")
	if _, ok := protocols[ctype]; !ok {
		http.Error(w, ctype+": unrecognized content type", http.StatusUnsupportedMediaType)
		return
	}

	c := &Call{
		ResponseWriter: w,
		Request:        r,
		ContentType:    ctype,
	}
	if err := handler(c); err != nil {
		w.Header().Set("Content-Type", "text/plain")
		http.Error(w, r.URL.Path+": "+err.Error(), http.StatusInternalServerError)
		return
	}
}

// DefaultServeMux is the default ServeMux used when nil is passed to the
// Register...Web functions and ListenAndServe.
var DefaultServeMux = ServeMux{}

// Post is used by the code generated automatically by protoc-gen-go for making
// RPC calls remotely.
func Post(protocol Protocol, base *url.URL, method string, in, out interface{}) error {
	b := new(bytes.Buffer)

	url := *base
	url.Path = path.Join(url.Path, DefaultRPCPath, method)

	if err := protocol.Encode(b, in); err != nil {
		return fmt.Errorf("webrpc.post: %s: marshal: %s", protocol, err)
	}

	req, err := http.NewRequest("POST", url.String(), b)
	if err != nil {
		return fmt.Errorf("webrpc.post: newrequest: %s", err)
	}
	req.Header.Set("Content-Type", protocol.String())
	req.Header.Set("Content-Length", fmt.Sprintf("%d", b.Len()))

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("webrpc.post: %s", err)
	}
	defer resp.Body.Close()

	b.Reset()
	if resp.StatusCode != http.StatusOK {
		if _, err := b.ReadFrom(resp.Body); err != nil {
			return fmt.Errorf("webrpc.post: read: %s", err)
		}
		return fmt.Errorf("webrc.post: %s: %s", resp.Status, bytes.TrimSpace(b.Bytes()))
	}

	if err := protocol.Decode(resp.Body, out); err != nil {
		return fmt.Errorf("webrpc.post: %s: unmarshal: %s in %q", protocol, err, b)
	}

	return nil
}

// ListenAndServe is a utility function for starting up the HTTP server without
// needing to import the net/http package.
func ListenAndServe(addr string, mux ServeMux) error {
	if mux == nil {
		mux = DefaultServeMux
	}
	return http.ListenAndServe(addr, mux)
}

func init() {
	http.Handle(DefaultRPCPath+"/", DefaultServeMux)
}
